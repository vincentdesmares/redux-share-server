{"version":3,"sources":["webpack:///webpack/universalModuleDefinition","webpack:///server.bundle.js","webpack:///webpack/bootstrap 01d1ccaf85bc055d354e","webpack:///./src/redux-share-server.js","webpack:///external \"body-parser\"","webpack:///external \"express\"","webpack:///external \"ws\""],"names":["root","factory","exports","module","require","define","amd","this","__WEBPACK_EXTERNAL_MODULE_1__","__WEBPACK_EXTERNAL_MODULE_2__","__WEBPACK_EXTERNAL_MODULE_3__","modules","__webpack_require__","moduleId","installedModules","id","loaded","call","m","c","p","_classCallCheck","instance","Constructor","TypeError","_createClass","defineProperties","target","props","i","length","descriptor","enumerable","configurable","writable","Object","defineProperty","key","protoProps","staticProps","prototype","bodyParser","WebSocketServer","Server","express","ReduxShareServer","server","options","_this","wss","store","defaultOptions","debug","onConnection","socket","socketNumber","onActionReceived","action","origin","shouldDispatch","type","shouldSend","repeaterMode","assign","readyToServe","value","router","Router","use","urlencoded","extended","json","post","req","res","body","log","dispatch","send","JSON","stringify","success","message","end","bind","get","getState","_this2","next","apply","result","undefined","broadcastAction","_startListen","property","clients","filter","arguments","map","sendToAction","tracedAction","_console","console","concat","Array","slice","on","parse","s"],"mappings":"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","file":"server.bundle.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory(require(\"body-parser\"), require(\"express\"), require(\"ws\"));\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([\"body-parser\", \"express\", \"ws\"], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"ReduxShareServer\"] = factory(require(\"body-parser\"), require(\"express\"), require(\"ws\"));\n\telse\n\t\troot[\"ReduxShareServer\"] = factory(root[\"body-parser\"], root[\"express\"], root[\"ws\"]);\n})(this, function(__WEBPACK_EXTERNAL_MODULE_1__, __WEBPACK_EXTERNAL_MODULE_2__, __WEBPACK_EXTERNAL_MODULE_3__) {\nreturn \n\n\n/** WEBPACK FOOTER **\n ** webpack/universalModuleDefinition\n **/","(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory(require(\"body-parser\"), require(\"express\"), require(\"ws\"));\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([\"body-parser\", \"express\", \"ws\"], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"ReduxShareServer\"] = factory(require(\"body-parser\"), require(\"express\"), require(\"ws\"));\n\telse\n\t\troot[\"ReduxShareServer\"] = factory(root[\"body-parser\"], root[\"express\"], root[\"ws\"]);\n})(this, function(__WEBPACK_EXTERNAL_MODULE_1__, __WEBPACK_EXTERNAL_MODULE_2__, __WEBPACK_EXTERNAL_MODULE_3__) {\nreturn /******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\texports: {},\n/******/ \t\t\tid: moduleId,\n/******/ \t\t\tloaded: false\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.loaded = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"/dist/\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(0);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\t\n\tvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\t\n\tfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\t\n\tvar bodyParser = __webpack_require__(1);\n\tvar WebSocketServer = __webpack_require__(3).Server;\n\tvar express = __webpack_require__(2);\n\t\n\tvar ReduxShareServer = function () {\n\t  /**\n\t   * Constructor of the server\n\t   *\n\t   * @param {Object} server\n\t   * @param {Object} options\n\t   */\n\t\n\t  function ReduxShareServer(server, options) {\n\t    var _this = this;\n\t\n\t    _classCallCheck(this, ReduxShareServer);\n\t\n\t    /**\n\t     * Websocket Server\n\t     */\n\t    this.wss = new WebSocketServer({ server: server });\n\t\n\t    /**\n\t     * Redux store to link to the clients\n\t     */\n\t    this.store = null;\n\t\n\t    var defaultOptions = {\n\t      //if set to true, will output debug on the console\n\t      debug: false,\n\t      //if set, this function will be called at connection time. Returns the socket.\n\t      onConnection: function onConnection(socket) {\n\t        socket.id = _this.socketNumber++;return socket;\n\t      },\n\t      //if set, this function will be called before receiving each action. Allow you to modify the action.\n\t      onActionReceived: function onActionReceived(action, socket) {\n\t        action.origin = socket.id;return action;\n\t      },\n\t      //if set, this function will filter all actions before dispatching. Returns bool.\n\t      shouldDispatch: function shouldDispatch(action) {\n\t        return action.type !== '@@SYNC-CONNECT-SERVER-SUCCESS';\n\t      },\n\t      //if set, this function will filter all actions before sending. Returns bool.\n\t      shouldSend: function shouldSend() {\n\t        return true;\n\t      },\n\t      //if true dispatches all actions received to all other connected clients. Please note that the API call to state bypasses this option.\n\t      repeaterMode: false\n\t    };\n\t\n\t    this.options = Object.assign({}, defaultOptions, options);\n\t\n\t    //internal state\n\t    this.readyToServe = false;\n\t    this.socketNumber = 0;\n\t  }\n\t\n\t  /**\n\t   * Return an Express middleware\n\t   *\n\t   * @returns {*}\n\t   */\n\t\n\t\n\t  _createClass(ReduxShareServer, [{\n\t    key: 'getExpressMiddleware',\n\t    value: function getExpressMiddleware() {\n\t      var router = express.Router();\n\t\n\t      router.use(bodyParser.urlencoded({ extended: false }));\n\t      router.use(bodyParser.json());\n\t\n\t      router.post('/action', function (req, res) {\n\t        var action = req.body;\n\t        this.log('Dispatching an action to the store', action);\n\t\n\t        if (this.store) {\n\t          this.store.dispatch(action);\n\t          res.send(JSON.stringify({ success: true }));\n\t        } else {\n\t          var message = \"Not ready yet, did you attach the redux middleware and dispatch the action @@SERVER-LISTEN-START?\";\n\t          this.log(message);\n\t          res.send(JSON.stringify({ success: false, message: message }));\n\t        }\n\t        res.end();\n\t      }.bind(this));\n\t\n\t      router.get('/state', function (req, res) {\n\t        res.send(JSON.stringify(this.store.getState(), null, 4));\n\t        res.end();\n\t      }.bind(this));\n\t\n\t      return router;\n\t    }\n\t\n\t    /**\n\t     * Get the middleware for Redux\n\t     * This middleware will broadcast server actions to all clients\n\t     *  \n\t     *  \n\t         store.dispatch  WS\n\t               |        |\n\t               |  onActionReceived()\n\t               |        |\n\t               v        v \n\t          +------------------+\n\t          |                  |\n\t          |                  |\n\t          |    Middleware    |\n\t          |                  |\n\t          |                  |\n\t          +--------+---------+\n\t                   |      \n\t           ShouldDispatch()? --------+\n\t                   |                 |\n\t        (next middleware...then)     |\n\t          +--------v---------+       |\n\t          |                  |       |\n\t          |                  |       |\n\t          |     Reducers     |       |\n\t          |                  |       |\n\t          |                  |       |\n\t          +--------+---------+       |\n\t                   |                 |\n\t                   |<----------------+\n\t                   |\n\t          +--------v---------+\n\t          |                  |\n\t          |    Middleware    |\n\t          |                  |\n\t          +--------+---------+\n\t                   |      \n\t                   V\n\t              ShouldSend()? \n\t                   |\n\t                   V\n\t                   WS\n\t     *\n\t     * @returns {Function}\n\t     */\n\t\n\t  }, {\n\t    key: 'getReduxMiddleware',\n\t    value: function getReduxMiddleware() {\n\t      var _this2 = this;\n\t\n\t      return function (store) {\n\t        return function (next) {\n\t          return function (action) {\n\t            _this2.log('Action \"' + action.type + '\" received by the redux middleware');\n\t\n\t            if (_this2.store === null) {\n\t              _this2.store = store;\n\t            }\n\t\n\t            //should dispatch?\n\t            if (_this2.options.shouldDispatch.apply(_this2, [action])) {\n\t              _this2.log(\"We dispatch this action \");\n\t              var result = next(action);\n\t            } else {\n\t              _this2.log(\"We dont dispatch this action \");\n\t              var result = null;\n\t            }\n\t\n\t            // If the action have been received, we don't send it back to the client\n\t            if (action.origin === undefined || action.origin === 'server') {\n\t              if (_this2.options.repeaterMode) {\n\t                _this2.broadcastAction(action);\n\t              }\n\t            }\n\t            if (action.type === \"@@SERVER-LISTEN-START\") _this2._startListen();\n\t            return result;\n\t          };\n\t        };\n\t      };\n\t    }\n\t\n\t    /**\n\t     * Finds a list of socket matching a property\n\t     *\n\t     * return [] if nothing found.\n\t     * @param property\n\t     * @param value.\n\t     * @returns {array}\n\t     */\n\t\n\t  }, {\n\t    key: 'findSockets',\n\t    value: function findSockets(property, value) {\n\t      return this.wss.clients.filter(function each(socket) {\n\t        return socket[property] !== undefined && socket[property] === value;\n\t      });\n\t    }\n\t\n\t    /**\n\t     * Broadcasts a message to all clients\n\t     * \n\t     * Bypasses the repeaterMode option.\n\t     * @param action\n\t     * @param senderSocket\n\t     * @returns array\n\t     */\n\t\n\t  }, {\n\t    key: 'broadcastAction',\n\t    value: function broadcastAction(action) {\n\t      var filter = arguments.length <= 1 || arguments[1] === undefined ? null : arguments[1];\n\t\n\t\n\t      this.log(\"Dispatches an action to all clients\", action);\n\t\n\t      if (typeof filter !== 'function') filter = function filter() {\n\t        return true;\n\t      };\n\t\n\t      return this.wss.clients.filter(filter).map(function each(socket) {\n\t        return this.sendToAction(action, socket);\n\t      }.bind(this));\n\t    }\n\t\n\t    /**\n\t     * Sends an action\n\t     * @param socket\n\t     * @param action\n\t     */\n\t\n\t  }, {\n\t    key: 'sendToAction',\n\t    value: function sendToAction(action, socket) {\n\t      var tracedAction = Object.assign({}, action, { origin: \"server\" });\n\t\n\t      if (this.options.shouldSend.apply(this, [tracedAction, socket])) {\n\t        this.log(\"Send to client \", socket.id, \" \", tracedAction);\n\t        return socket.send(JSON.stringify(tracedAction));\n\t      } else {\n\t        this.log(\"Do not send to client \", socket.id, \" \", tracedAction);\n\t      }\n\t    }\n\t\n\t    /**\n\t    * Internal log function\n\t    *\n\t    */\n\t\n\t  }, {\n\t    key: 'log',\n\t    value: function log() {\n\t      if (this.options.debug) {\n\t        var _console;\n\t\n\t        (_console = console).log.apply(_console, [\"redux-share-server: \"].concat(Array.prototype.slice.call(arguments)));\n\t      }\n\t    }\n\t\n\t    /**\n\t    * Private method to init the store\n\t    */\n\t\n\t  }, {\n\t    key: '_startListen',\n\t    value: function _startListen() {\n\t\n\t      this.wss.on('connection', function connection(socket) {\n\t        if (typeof this.options.onConnection == 'function') {\n\t          socket = this.options.onConnection(socket) || socket;\n\t        }\n\t\n\t        socket.on('message', function incoming(message) {\n\t          this.log(\"Received from client the message \", message);\n\t\n\t          var action = JSON.parse(message);\n\t\n\t          if (typeof this.options.onActionReceived == 'function') {\n\t\n\t            action = this.options.onActionReceived.apply(this, [action, socket]);\n\t          }\n\t\n\t          this.log('Dispatching the action to the store', action);\n\t\n\t          if (this.store) {\n\t            this.store.dispatch(action);\n\t          } else {\n\t            this.log('Store not ready yet, did you forget to add the redux middleware?');\n\t          }\n\t\n\t          if (this.options.repeaterMode) {\n\t            this.broadcastAction(action, function (s) {\n\t              return s !== socket;\n\t            });\n\t          }\n\t        }.bind(this));\n\t      }.bind(this));\n\t      this.readyToServe = true;\n\t    }\n\t  }]);\n\t\n\t  return ReduxShareServer;\n\t}();\n\t\n\tmodule.exports = ReduxShareServer;\n\n/***/ },\n/* 1 */\n/***/ function(module, exports) {\n\n\tmodule.exports = require(\"body-parser\");\n\n/***/ },\n/* 2 */\n/***/ function(module, exports) {\n\n\tmodule.exports = require(\"express\");\n\n/***/ },\n/* 3 */\n/***/ function(module, exports) {\n\n\tmodule.exports = require(\"ws\");\n\n/***/ }\n/******/ ])\n});\n;\n\n\n/** WEBPACK FOOTER **\n ** server.bundle.js\n **/"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\texports: {},\n \t\t\tid: moduleId,\n \t\t\tloaded: false\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.loaded = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"/dist/\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(0);\n\n\n\n/** WEBPACK FOOTER **\n ** webpack/bootstrap 01d1ccaf85bc055d354e\n **/","\"use strict\";\nvar bodyParser = require('body-parser');\nvar WebSocketServer = require('ws').Server;\nvar express = require('express');\n\n\nclass ReduxShareServer {\n  /**\n   * Constructor of the server\n   *\n   * @param {Object} server\n   * @param {Object} options\n   */\n  constructor (server,\n               options) {\n    /**\n     * Websocket Server\n     */\n    this.wss = new WebSocketServer({server: server});\n    \n\n    /**\n     * Redux store to link to the clients\n     */\n    this.store = null;\n\n    let defaultOptions = {\n      //if set to true, will output debug on the console\n      debug:false,\n      //if set, this function will be called at connection time. Returns the socket.\n      onConnection: (socket) => { socket.id = this.socketNumber++; return socket; },\n      //if set, this function will be called before receiving each action. Allow you to modify the action.\n      onActionReceived: (action,socket) => { action.origin = socket.id; return action; },\n      //if set, this function will filter all actions before dispatching. Returns bool.\n      shouldDispatch: action => (action.type !== '@@SYNC-CONNECT-SERVER-SUCCESS'), \n      //if set, this function will filter all actions before sending. Returns bool.\n      shouldSend: () => true,\n      //if true dispatches all actions received to all other connected clients. Please note that the API call to state bypasses this option.\n      repeaterMode:false\n    };\n\n    this.options = Object.assign({},defaultOptions,options);\n\n    //internal state\n    this.readyToServe = false;\n    this.socketNumber = 0;\n  }\n\n  /**\n   * Return an Express middleware\n   *\n   * @returns {*}\n   */\n  getExpressMiddleware () {\n    var router = express.Router();\n\n    router.use(bodyParser.urlencoded({extended: false}));\n    router.use(bodyParser.json())\n\n    router.post('/action', function (req, res) {\n      let action = req.body;\n      this.log('Dispatching an action to the store', action);\n      \n      if(this.store) {\n        this.store.dispatch(action);\n        res.send(JSON.stringify({success: true}));\n      }\n      else {\n        let message = \"Not ready yet, did you attach the redux middleware and dispatch the action @@SERVER-LISTEN-START?\";\n        this.log(message);\n        res.send(JSON.stringify({ success: false, message:message }));\n      }\n      res.end();\n      \n    }.bind(this));\n\n    router.get('/state', function (req, res) {\n      res.send(JSON.stringify(this.store.getState(), null, 4));\n      res.end();\n    }.bind(this));\n\n    return router;\n  }\n\n  /**\n   * Get the middleware for Redux\n   * This middleware will broadcast server actions to all clients\n   *  \n   *  \n\n      store.dispatch  WS\n             |        |\n             |  onActionReceived()\n             |        |\n             v        v \n        +------------------+\n        |                  |\n        |                  |\n        |    Middleware    |\n        |                  |\n        |                  |\n        +--------+---------+\n                 |      \n         ShouldDispatch()? --------+\n                 |                 |\n      (next middleware...then)     |\n        +--------v---------+       |\n        |                  |       |\n        |                  |       |\n        |     Reducers     |       |\n        |                  |       |\n        |                  |       |\n        +--------+---------+       |\n                 |                 |\n                 |<----------------+\n                 |\n        +--------v---------+\n        |                  |\n        |    Middleware    |\n        |                  |\n        +--------+---------+\n                 |      \n                 V\n            ShouldSend()? \n                 |\n                 V\n                 WS\n   *\n   * @returns {Function}\n   */\n  getReduxMiddleware() {\n    return store => next => action => {\n      this.log('Action \"' + action.type + '\" received by the redux middleware');\n\n      if(this.store === null) {\n        this.store = store;\n      }\n\n      //should dispatch?\n      if(this.options.shouldDispatch.apply(this,[action]) ) {\n        this.log(\"We dispatch this action \");\n        var result = next(action);\n      }\n      else {\n        this.log(\"We dont dispatch this action \");\n        var result = null;\n      }\n      \n      // If the action have been received, we don't send it back to the client\n      if (action.origin === undefined || action.origin === 'server') {\n        if (this.options.repeaterMode) {\n          this.broadcastAction(action);\n        }\n      }\n      if (action.type === \"@@SERVER-LISTEN-START\") this._startListen();\n      return result;\n    }\n  }\n\n  /**\n   * Finds a list of socket matching a property\n   *\n   * return [] if nothing found.\n   * @param property\n   * @param value.\n   * @returns {array}\n   */\n  findSockets(property,value) {\n    return this.wss.clients.filter(function each (socket) {\n      return (socket[property] !== undefined && socket[property] === value);\n    });\n  }\n\n  /**\n   * Broadcasts a message to all clients\n   * \n   * Bypasses the repeaterMode option.\n   * @param action\n   * @param senderSocket\n   * @returns array\n   */\n  broadcastAction(action,filter = null) {\n\n    this.log(\"Dispatches an action to all clients\", action);\n\n    if(typeof(filter) !== 'function') filter = () => true;\n    \n    return this.wss.clients.filter(filter).map(function each (socket) {\n      return this.sendToAction(action, socket);\n    }.bind(this));\n  }\n\n\n  /**\n   * Sends an action\n   * @param socket\n   * @param action\n   */\n  sendToAction(action,socket) {\n    let tracedAction = Object.assign({},action,{origin:\"server\" });\n    \n    if(this.options.shouldSend.apply(this, [tracedAction, socket])) {\n      this.log(\"Send to client \", socket.id,\" \",tracedAction);\n      return socket.send(JSON.stringify(tracedAction));\n    }\n    else {\n      this.log(\"Do not send to client \", socket.id, \" \",tracedAction);\n    }\n\n  }\n\n  /**\n  * Internal log function\n  *\n  */\n  log() {\n    if (this.options.debug) {\n        console.log(\"redux-share-server: \", ...arguments);\n      }\n  }\n\n  /**\n  * Private method to init the store\n  */\n  _startListen() {\n\n    this.wss.on('connection', function connection (socket) {\n      if (typeof(this.options.onConnection) == 'function') {\n        socket = this.options.onConnection(socket) || socket;\n      }\n\n      socket.on('message', function incoming (message) {\n        this.log(\"Received from client the message \",message);\n\n        let action = JSON.parse(message);\n\n        if (typeof(this.options.onActionReceived) == 'function') {\n\n          action = this.options.onActionReceived.apply(this, [action, socket])\n        }\n\n        this.log('Dispatching the action to the store', action);\n\n        if(this.store) {\n          this.store.dispatch(action);\n        }\n        else {\n          this.log('Store not ready yet, did you forget to add the redux middleware?')\n        }\n\n        if (this.options.repeaterMode) {\n          this.broadcastAction(action,s => s !== socket);\n        }\n      }.bind(this));\n\n    }.bind(this));\n    this.readyToServe = true;\n  }\n\n}\n\n\nmodule.exports = ReduxShareServer;\n\n\n/** WEBPACK FOOTER **\n ** ./src/redux-share-server.js\n **/","module.exports = require(\"body-parser\");\n\n\n/*****************\n ** WEBPACK FOOTER\n ** external \"body-parser\"\n ** module id = 1\n ** module chunks = 0\n **/","module.exports = require(\"express\");\n\n\n/*****************\n ** WEBPACK FOOTER\n ** external \"express\"\n ** module id = 2\n ** module chunks = 0\n **/","module.exports = require(\"ws\");\n\n\n/*****************\n ** WEBPACK FOOTER\n ** external \"ws\"\n ** module id = 3\n ** module chunks = 0\n **/"],"sourceRoot":""}